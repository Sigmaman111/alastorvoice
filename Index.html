<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Radio Demon Voice Effect</title>
<style>
body{
    font-family: Arial, sans-serif;
    background:#111;
    color:#eee;
    text-align:center;
    padding:40px;
}
button, input{
    margin:10px;
    padding:10px 15px;
    font-size:16px;
}
audio{
    margin-top:20px;
    width:80%;
}
</style>
</head>
<body>

<h1>Radio Demon Voice Effect</h1>

<input type="file" id="fileInput" accept="audio/*">
<br>

<button id="recordBtn">Start Recording</button>
<button id="stopBtn" disabled>Stop Recording</button>
<br>

<button id="processBtn" disabled>Apply Voice Effect</button>

<audio id="outputAudio" controls></audio>
<br>
<a id="downloadLink" style="display:none">Download processed audio</a>

<script>
let audioContext = new (window.AudioContext || window.webkitAudioContext)();
let recordedChunks = [];
let mediaRecorder;
let rawArrayBuffer = null;

/* ---------------- RECORDING ---------------- */

document.getElementById("recordBtn").onclick = async () => {
    const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
    mediaRecorder = new MediaRecorder(stream);

    recordedChunks = [];
    mediaRecorder.ondataavailable = e => recordedChunks.push(e.data);

    mediaRecorder.onstop = async () => {
        const blob = new Blob(recordedChunks);
        rawArrayBuffer = await blob.arrayBuffer();
        document.getElementById("processBtn").disabled = false;
    };

    mediaRecorder.start();
    recordBtn.disabled = true;
    stopBtn.disabled = false;
};

document.getElementById("stopBtn").onclick = () => {
    mediaRecorder.stop();
    recordBtn.disabled = false;
    stopBtn.disabled = true;
};

/* ---------------- FILE UPLOAD ---------------- */

document.getElementById("fileInput").onchange = async e => {
    rawArrayBuffer = await e.target.files[0].arrayBuffer();
    document.getElementById("processBtn").disabled = false;
};

/* ---------------- AUDIO PROCESSING ---------------- */

document.getElementById("processBtn").onclick = async () => {

    const decoded = await audioContext.decodeAudioData(rawArrayBuffer);

    /* --- create offline renderer --- */
    const offline = new OfflineAudioContext(
        decoded.numberOfChannels,
        decoded.length,
        decoded.sampleRate
    );

    const source = offline.createBufferSource();
    source.buffer = decoded;

    /* --- slight pitch up --- */
    source.playbackRate.value = 1.15;

    /* --- bandpass (radio tone) --- */
    const bandpass = offline.createBiquadFilter();
    bandpass.type = "bandpass";
    bandpass.frequency.value = 1600;
    bandpass.Q.value = 1.2;

    /* --- distortion --- */
    const distortion = offline.createWaveShaper();
    distortion.curve = makeDistortionCurve(400);
    distortion.oversample = "4x";

    /* --- small reverb --- */
    const convolver = offline.createConvolver();
    convolver.buffer = createImpulse(offline, 0.3, 2);

    /* --- chain --- */
    source.connect(bandpass);
    bandpass.connect(distortion);
    distortion.connect(convolver);
    convolver.connect(offline.destination);

    source.start();

    const rendered = await offline.startRendering();

    playAndExport(rendered);
};

/* ---------------- HELPERS ---------------- */

function makeDistortionCurve(amount){
    const samples = 44100;
    const curve = new Float32Array(samples);
    const deg = Math.PI / 180;

    for(let i=0;i<samples;i++){
        const x = i * 2 / samples - 1;
        curve[i] = (3 + amount) * x * 20 * deg /
                   (Math.PI + amount * Math.abs(x));
    }
    return curve;
}

function createImpulse(ctx, duration, decay){
    const length = ctx.sampleRate * duration;
    const impulse = ctx.createBuffer(2, length, ctx.sampleRate);

    for(let ch=0; ch<2; ch++){
        const data = impulse.getChannelData(ch);
        for(let i=0;i<length;i++){
            data[i] = (Math.random()*2-1) *
                      Math.pow(1 - i/length, decay);
        }
    }
    return impulse;
}

function playAndExport(buffer){

    const wav = bufferToWav(buffer);
    const blob = new Blob([wav], {type:"audio/wav"});
    const url = URL.createObjectURL(blob);

    const audio = document.getElementById("outputAudio");
    audio.src = url;

    const link = document.getElementById("downloadLink");
    link.href = url;
    link.download = "processed_voice.wav";
    link.style.display = "inline";
    link.textContent = "Download processed audio";
}

/* ---------------- WAV ENCODER ---------------- */

function bufferToWav(buffer){
    const numOfChan = buffer.numberOfChannels;
    const length = buffer.length * numOfChan * 2 + 44;
    const view = new DataView(new ArrayBuffer(length));

    writeString(view, 0, "RIFF");
    view.setUint32(4, 36 + buffer.length * numOfChan * 2, true);
    writeString(view, 8, "WAVE");
    writeString(view, 12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, numOfChan, true);
    view.setUint32(24, buffer.sampleRate, true);
    view.setUint32(28, buffer.sampleRate * numOfChan * 2, true);
    view.setUint16(32, numOfChan * 2, true);
    view.setUint16(34, 16, true);
    writeString(view, 36, "data");
    view.setUint32(40, buffer.length * numOfChan * 2, true);

    let offset = 44;
    for(let i=0;i<buffer.length;i++){
        for(let ch=0; ch<numOfChan; ch++){
            let sample = buffer.getChannelData(ch)[i];
            sample = Math.max(-1, Math.min(1, sample));
            view.setInt16(offset, sample < 0 ? sample*0x8000 : sample*0x7FFF, true);
            offset += 2;
        }
    }
    return view;
}

function writeString(view, offset, string){
    for(let i=0;i<string.length;i++){
        view.setUint8(offset+i, string.charCodeAt(i));
    }
}
</script>

</body>
</html>
