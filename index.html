<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Alastor Voice Effect</title>
<style>
body {
    font-family: Arial, sans-serif;
    background: #111;
    color: #eee;
    text-align: center;
    padding: 40px;
}
button, input {
    margin: 10px;
    padding: 10px 15px;
    font-size: 16px;
}
audio {
    margin-top: 20px;
    width: 80%;
}
#progressContainer {
    width: 80%;
    height: 20px;
    background: #333;
    margin: 20px auto;
    border-radius: 10px;
    overflow: hidden;
}
#progressBar {
    width: 0%;
    height: 100%;
    background: #e33;
    transition: width 0.2s;
}
</style>
</head>
<body>

<h1>Alastor Voice Effect</h1>

<input type="file" id="fileInput" accept="audio/*">
<br>
<button id="processBtn" disabled>Apply Voice Effect</button>

<div id="progressContainer">
    <div id="progressBar"></div>
</div>

<audio id="outputAudio" controls></audio>
<br>
<a id="downloadLink" style="display:none">Download processed audio</a>

<script>
let audioContext = new (window.AudioContext || window.webkitAudioContext)();
let rawArrayBuffer = null;

const fileInput = document.getElementById('fileInput');
const processBtn = document.getElementById('processBtn');
const progressBar = document.getElementById('progressBar');

fileInput.onchange = async e => {
    rawArrayBuffer = await e.target.files[0].arrayBuffer();
    processBtn.disabled = false;
};

processBtn.onclick = async () => {
    if (!rawArrayBuffer) return;

    processBtn.disabled = true;
    progressBar.style.width = '0%';

    const decoded = await audioContext.decodeAudioData(rawArrayBuffer);
    const offline = new OfflineAudioContext(
        decoded.numberOfChannels,
        decoded.length,
        decoded.sampleRate
    );

    const source = offline.createBufferSource();
    source.buffer = decoded;
    source.playbackRate.value = 1.15; // slight pitch up

    const bandpass = offline.createBiquadFilter();
    bandpass.type = 'bandpass';
    bandpass.frequency.value = 1600;
    bandpass.Q.value = 1.2;

    const distortion = offline.createWaveShaper();
    distortion.curve = makeDistortionCurve(400);
    distortion.oversample = '4x';

    const convolver = offline.createConvolver();
    convolver.buffer = createImpulse(offline, 0.3, 2);

    source.connect(bandpass);
    bandpass.connect(distortion);
    distortion.connect(convolver);
    convolver.connect(offline.destination);

    source.start();

    // Progress monitoring
    let rendered = null;
    const renderPromise = offline.startRendering().then(res => { rendered = res; });
    let progressInterval = setInterval(() => {
        if (!rendered) {
            let currentTime = offline.currentTime || 0;
            let total = decoded.duration || 1;
            let percent = Math.min(100, (currentTime / total) * 100);
            progressBar.style.width = percent + '%';
        } else {
            progressBar.style.width = '100%';
            clearInterval(progressInterval);
        }
    }, 100);

    await renderPromise;

    playAndExport(rendered);
    processBtn.disabled = false;
};

// ----- Helpers -----
function makeDistortionCurve(amount) {
    const samples = 44100;
    const curve = new Float32Array(samples);
    const deg = Math.PI / 180;
    for (let i = 0; i < samples; i++) {
        const x = i * 2 / samples - 1;
        curve[i] = (3 + amount) * x * 20 * deg / (Math.PI + amount * Math.abs(x));
    }
    return curve;
}

function createImpulse(ctx, duration, decay) {
    const length = ctx.sampleRate * duration;
    const impulse = ctx.createBuffer(2, length, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const data = impulse.getChannelData(ch);
        for (let i = 0; i < length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
    }
    return impulse;
}

function playAndExport(buffer) {
    const wav = bufferToWav(buffer);
    const blob = new Blob([wav], {type: "audio/wav"});
    const url = URL.createObjectURL(blob);

    const audio = document.getElementById('outputAudio');
    audio.src = url;

    const link = document.getElementById('downloadLink');
    link.href = url;
    link.download = "processed_voice.wav";
    link.style.display = "inline";
    link.textContent = "Download processed audio";
}

// ----- WAV encoder -----
function bufferToWav(buffer) {
    const numOfChan = buffer.numberOfChannels;
    const length = buffer.length * numOfChan * 2 + 44;
    const view = new DataView(new ArrayBuffer(length));
    writeString(view, 0, "RIFF");
    view.setUint32(4, 36 + buffer.length * numOfChan * 2, true);
    writeString(view, 8, "WAVE");
    writeString(view, 12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, numOfChan, true);
    view.setUint32(24, buffer.sampleRate, true);
    view.setUint32(28, buffer.sampleRate * numOfChan * 2, true);
    view.setUint16(32, numOfChan * 2, true);
    view.setUint16(34, 16, true);
    writeString(view, 36, "data");
    view.setUint32(40, buffer.length * numOfChan * 2, true);

    let offset = 44;
    for (let i = 0; i < buffer.length; i++) {
        for (let ch = 0; ch < numOfChan; ch++) {
            let sample = buffer.getChannelData(ch)[i];
            sample = Math.max(-1, Math.min(1, sample));
            view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
            offset += 2;
        }
    }
    return view;
}

function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}
</script>

</body>
</html>
